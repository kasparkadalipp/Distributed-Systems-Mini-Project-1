syntax = "proto3";

package project;

enum Status {
  SUCCESS = 0;
  FAILURE = 1;
}

enum Player {
  O = 0;
  X = 1;
}

enum Result {
  DRAW = 0;
  WIN = 1;
  LOSS = 2;
}

service GameService {
  // ================== TIME SYNCHRONISATION ======================
   // Used by leader to query nodes for their time
  rpc GetTime(TimeRequest) returns (TimeResponse) {}

  // Used by leader to inform nodes about required clock adjustments
  rpc AdjustClock(AdjustClockRequest) returns (AdjustClockResponse) {}

  // Used by leader for manual clock adjustments
  rpc SetClock(SetClockRequest) returns (SetClockResponse) {}


  // ================== LEADER ELECTION ======================
  // the function will handle the election process
  rpc AssumeLeader (LeaderRequest) returns (LeaderResponse);
  // new leader is ready to take over
  rpc Coordinator (NewLeader) returns (Acknowledged);

  // ================== GAME LOGIC ======================
  // Some ideas about the missing/remaining stuff:
  // - Master should, upon start of game, assign symbol (O/X) to slave nodes
  // - Master needs to inform slaves once it is their turn (board state should be included, including for what player the turn needs to be made for)
  rpc JoinGame (JoinGameRequest) returns (JoinGameResponse);
  rpc ListBoard (ListBoardRequest) returns (ListBoardResponse);
  rpc RequestMove (RequestTurn) returns (Acknowledged);
  // place X or O
  rpc MakeTurn (MakeTurn) returns (MakeTurnResponse);
  rpc DeclareWinner (AnnounceWinner) returns (Acknowledged);
}



message TimeRequest {
}

message TimeResponse {
  // unix timestamp (milliseconds since epoch)
  uint64 unix_time_ms = 1;
}

message AdjustClockRequest {
  // offset in milliseconds to be added to current clock:
  // - positive value indicating amount of milliseconds to be added (in case node time lags behind current time)
  // - negative value indicating amount of milliseconds to be substracted (in case node time leads in front of current time)
  int64 offset_ms = 1;
}

message AdjustClockResponse {
  // request will result in failure in case issued by non-leader node
  Status status = 1;
  string message = 2;
}

message SetClockRequest {
  // unix timestamp (milliseconds since epoch)
  uint64 unix_time_ms = 1;
}

message SetClockResponse {
  // request will result in failure in case issued by non-leader node
  Status status = 1;
  string message = 2;
}


message LeaderRequest { int32 senderNodeId = 1; }
message LeaderResponse { bool acknowledged = 1; }
message NewLeader { int32 coordinator_id = 1; }
message Acknowledged{ }

message AnnounceWinner {
  string board_state = 1;
  bool is_winner = 2;
}

message MakeTurnResponse {
  // request will result in failure in case issued by non-leader node
  Status status = 1;
  string message = 2;
}

message RequestTurn {
  string board_state = 1;
  Player mark = 2;
}

message MakeTurn {
  int32 player_id = 1;
  int32 board_position = 2;
}


message JoinGameRequest {
  int32 player_id = 1;
}

message JoinGameResponse {
  bool gameStarted = 1;
}

message ListBoardRequest {
}

message ListBoardResponse {
  // request will result in failure in case issued to non-leader node
  Status status = 1;
  string message = 2;

  // maps field identifier (number between 0 and 8) to player that occupies field (if any)
  map<uint32,Player> board = 3;
}


service ElectionService {
  // Need to agree upon algorithm...
}